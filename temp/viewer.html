<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>peerjs callee</title>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <style>
        div {
            position: relative;
            text-align: center;
        }
        span {
            position: absolute;
            left: 50%;
            transform: translate(-50%,-50%);
            z-index: 1;
            font-size: x-large;
            font-weight: bold;
            background-color: azure;

        }
        span.label {
            top: 5%;
        }
        span.stats{
            bottom: 5%;
        }
        video {
            /*transform: scale(-1, 1);*/
            z-index: -1;
        }
    </style>
</head>
<body>
<div>
    <span id="label" class="label"></span>
    <video autoplay playsinline muted></video><br>
    <span id="stats" class="stats"></span>
    <p>Click on the video to switch between the local camera and the remote stream</p>
</div>
<div>
    <p>Apply constraints to the current video</p>
    <button id="uhd">1920x1080</button>
    <button id="hd">1280x720</button>
    <button id="qhd">960x540</button>
    <button id="vga">640x480</button>
</div>
<script>
    let video = document.querySelector('video');
    let statsText = document.getElementById('stats');
    let labelText = document.getElementById('label');
    let remoteStream;


    function createStandbyStream() {
        let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');
        canvas.width = 1280;
        canvas.height = 720;

        // source: https://codepen.io/tmrDevelops/pen/vOPZBv
        let col = (x, y, r, g, b) => {
            ctx.fillStyle = `rgb(${r}, ${g}, ${b}`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = "92px Arial";
            ctx.fillStyle = "rgb(225,225,225)";
            ctx.fillText('phonecam not connected', canvas.height*.1, canvas.width/2);
        };

        let R = (x, y, t) => Math.floor(192 + 64 * Math.cos((x * x - y * y) / 300 + t));
        let G = (x, y, t) => Math.floor(192 + 64 * Math.sin((x * x * Math.cos(t / 4) + y * y * Math.sin(t / 3)) / 300));
        let B = (x, y, t) => Math.floor(192 + 64 * Math.sin(5 * Math.sin(t / 9) + ((x - 100) * (x - 100) + (y - 100) * (y - 100)) / 1100));

        let t = 0;

        function colors() {
            for (let x = 0; x <= 35; x++) {
                for (let y = 0; y <= 35; y++) {
                    col(x, y, R(x, y, t), G(x, y, t), B(x, y, t));
                }
            }
            t = t + 0.120;
        }

        setInterval(() => requestAnimationFrame(colors), 200);
        return canvas.captureStream();
    }


    // Start with the standby stream
    standbyStream = createStandbyStream();
    video.srcObject = standbyStream;
    labelText.innerText = 'Standby';

    // Setup & connect to the remote stream

    const peerId = '2ceef1a5-2145-43a6-8cba-235423af1412';
    let peer = new Peer( `${peerId}-viewer`, {debug: 3});

    // ToDo: fix this
    // video stats
    video.onloadedmetadata = () =>{

        let decodedFrames = 0,
            droppedFrames = 0,
            startTime = new Date().getTime(),
            initialTime = new Date().getTime();

        setInterval(()=>{

            let currentTime = new Date().getTime();
            let deltaTime = (currentTime - startTime) / 1000;
            // let totalTime = (currentTime - initialTime) / 1000;
            startTime = currentTime;

            // Calculate decoded frames per sec.
            let currentDecodedFPS  = (video.webkitDecodedFrameCount - decodedFrames) / deltaTime;
            //let decodedFPSavg = video.webkitDecodedFrameCount / totalTime;
            decodedFrames = video.webkitDecodedFrameCount;

            // Calculate dropped frames per sec.
            //let currentDroppedFPS = (video.webkitDroppedFrameCount - droppedFrames) / deltaTime;
            //let droppedFPSavg = video.webkitDroppedFrameCount / totalTime;
            droppedFrames = video.webkitDroppedFrameCount;

            statsText.innerText = `${video.videoHeight}p${currentDecodedFPS.toFixed(1)}`;
        }, 500)

    };
    peer.on('open',  id=> console.log(`My peer ID is ${id}. Waiting for call`));

    peer.on('connection', conn => {
        conn.on('data', data => console.log(`Incoming data: ${data}`))
    });
    peer.on('disconnected', ()=>console.log("Peer disconnected"));

    peer.on('call', call=>{
        call.on('stream', stream=>{
            console.log("Got stream, switching source");
            remoteStream = stream;
            video.srcObject = remoteStream;
            labelText.innerText = 'Remote';

            // stream.on not a function
            // stream.on('close', ()=> "Peer stream stopped");
            // stream.on('error', err=>console.error(err));

        });
        console.log("Answering incoming call");
        call.answer();
    });


    // ToDo: add getUserMedia, switch to gUM video
    video.addEventListener('click', ()=>{
        if(labelText.innerText==="Standby"){
            if(remoteStream && remoteStream.active){
                video.srcObject = remoteStream;
                labelText.innerText = 'Remote';
                console.log("Set remote stream");
            }
            else{
                video.srcObject = null;
                labelText.innerText = 'Remote unavailable';
                console.log("Set remote stream attempt - unavailable");
            }

        }
        else if(standbyStream && (labelText.innerText==="Remote" || labelText.innerText==="Remote unavailable")) {
            video.srcObject = standbyStream;
            labelText.innerText = 'Standby';
            console.log("Set standby stream");
        }
        else
            console.error("No stream available to switch or invalid state");
    });


    /*
     * Apply track constraints
     */

    async function setResolution(width, height){
        let constraints = {
                width: { exact: width},
                height: {exact: height}
            };
        let stream = video.srcObject;



        /*
        const oldTrack = video.srcObject.getVideoTracks()[0];
        console.log("current settings", oldTrack.getSettings());
        NOTE: this didn't work - newTrack is null
        const newTrack = await oldTrack.applyConstraints(constraints);
        console.log(newTrack);
        console.log("new settings", newTrack.getSettings());
        oldTrack.stop();
        stream.addTrack(newTrack);
         */
        const track = video.srcObject.getVideoTracks()[0];
        console.log("current settings", track.getSettings());
        await track.applyConstraints(constraints);
        console.log("new settings", track.getSettings());
    }
    let uhdBtn = document.querySelector('button#uhd');
    let hdBtn = document.querySelector('button#hd');
    let qhdBtn = document.querySelector('button#qhd');
    let vgaBtn = document.querySelector('button#vga');

    uhdBtn.addEventListener('click', ()=> setResolution(1920,1080));
    hdBtn.addEventListener('click', ()=> setResolution(1280,720));
    qhdBtn.addEventListener('click', ()=> setResolution(960,540));
    vgaBtn.addEventListener('click', ()=> setResolution(640,490));


</script>
</body>
</html>
